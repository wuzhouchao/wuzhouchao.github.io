<!DOCTYPE html><html lang="中文" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>前端js机制-基础 | 吴超的技术博客</title><meta name="description" content="js如何浅拷贝和深拷贝一个对象浅拷贝:  创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。 浅拷贝:  Object.assign()"><meta name="author" content="吴超"><meta name="copyright" content="吴超"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/09/22/%E5%89%8D%E7%AB%AFjs%E6%9C%BA%E5%88%B6-%E5%9F%BA%E7%A1%80/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="前端js机制-基础"><meta property="og:url" content="http://yoursite.com/2020/09/22/%E5%89%8D%E7%AB%AFjs%E6%9C%BA%E5%88%B6-%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="吴超的技术博客"><meta property="og:description" content="js如何浅拷贝和深拷贝一个对象浅拷贝:  创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。 浅拷贝:  Object.assign()"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-09-22T02:13:38.177Z"><meta property="article:modified_time" content="2020-09-22T02:13:38.388Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="css-html重点总结" href="http://yoursite.com/2020/09/22/css-html%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93/"><link rel="next" title="vue基础" href="http://yoursite.com/2020/09/22/vue%E5%9F%BA%E7%A1%80/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page"><span> 列表</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#js如何浅拷贝和深拷贝一个对象"><span class="toc-number">1.</span> <span class="toc-text">js如何浅拷贝和深拷贝一个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rem和em和px的区别"><span class="toc-number">2.</span> <span class="toc-text">rem和em和px的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for循环中break和continue的区别是什么"><span class="toc-number">3.</span> <span class="toc-text">for循环中break和continue的区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何用原生js给一个按钮的点击事件绑定两个事件处理函数"><span class="toc-number">4.</span> <span class="toc-text">如何用原生js给一个按钮的点击事件绑定两个事件处理函数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js引擎如何实现异步的"><span class="toc-number">5.</span> <span class="toc-text">js引擎如何实现异步的?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#宏任务-amp-微任务"><span class="toc-number">5.1.</span> <span class="toc-text">宏任务 &amp; 微任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是防抖节流"><span class="toc-number">6.</span> <span class="toc-text">什么是防抖节流?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是函数柯理化"><span class="toc-number">7.</span> <span class="toc-text">什么是函数柯理化?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是js事件循环-event-loop"><span class="toc-number">8.</span> <span class="toc-text">什么是js事件循环?(event-loop)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http和https有什么区别"><span class="toc-number">9.</span> <span class="toc-text">http和https有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你认为前端页面实时刷新数据的方法有哪些"><span class="toc-number">10.</span> <span class="toc-text">你认为前端页面实时刷新数据的方法有哪些?</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">吴超的技术博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page"><span> 列表</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">前端js机制-基础</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-09-22 10:13:38"><i class="far fa-calendar-alt fa-fw"></i> Created 2020-09-22</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-09-22 10:13:38"><i class="fas fa-history fa-fw"></i> Updated 2020-09-22</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="js如何浅拷贝和深拷贝一个对象"><a href="#js如何浅拷贝和深拷贝一个对象" class="headerlink" title="js如何浅拷贝和深拷贝一个对象"></a>js如何浅拷贝和深拷贝一个对象</h3><p>浅拷贝:  创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。<br>深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</p>
<p>浅拷贝:</p>
<ul>
<li><p><strong>Object.assign() 方法：</strong> 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<p><img src= "/img/loading.gif" data-src="C:%5CUsers%5CDouyaJ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902095419236.png" alt="image-20200902095419236"></p>
</li>
<li><p><strong>Array.prototype.slice()：</strong>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p>
</li>
<li><p><strong>拓展运算符</strong><code>...</code>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;    </span><br><span class="line">    name: <span class="string">"Jake"</span>,    </span><br><span class="line">    flag: &#123;</span><br><span class="line">        title: <span class="string">"better day by day"</span>,        </span><br><span class="line">        time: <span class="string">"2020-05-31"</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br></pre></td></tr></table></figure>

<p>深拷贝:</p>
<p><strong>乞丐版：</strong> JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）</p>
<p><img src= "/img/loading.gif" data-src="C:%5CUsers%5CDouyaJ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200914195654768.png" alt="image-20200914195654768"></p>
<ul>
<li><p>递归法</p>
<p>优点：能够实现对象和数组的深拷贝</p>
<p>缺点：如果拷贝的对象嵌套过深的话，会对性能有一定的消耗</p>
</li>
</ul>
<p>  解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。这个存储空间，需要可以存储 <code>key-value</code>形式的数据，且 <code>key</code>可以是一个引用类型，我们可以选择 <code>Map</code>这种数据结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.检查map中有无克隆过的对象</span></span><br><span class="line"><span class="comment">.有 - 直接返回</span></span><br><span class="line"><span class="comment">.没有 - 将当前对象作为key，克隆对象作为value进行存储</span></span><br><span class="line"><span class="comment">.继续克隆</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如果我们要拷贝的对象非常庞大时，使用 Map会对内存造成非常大的额外消耗，而且我们需要手动清除 Map的属性才能释放这块内存，而 WeakMap会帮我们巧妙化解这个问题。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">target,map = new WeakMap(</span>)) </span>&#123; </span><br><span class="line">    <span class="comment">//WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</span></span><br><span class="line">    <span class="keyword">if</span>(typeOf taret ===<span class="string">'object'</span>)&#123;    </span><br><span class="line">      <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">   	  <span class="keyword">if</span>(map.get(target)) &#123;    </span><br><span class="line">         <span class="keyword">return</span> target;   </span><br><span class="line">   	  &#125;     </span><br><span class="line">      map.set(target, cloneTarget);   </span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> target)&#123;       </span><br><span class="line">         cloneTarget[key] = cloneDeep(target[key], map);  </span><br><span class="line">      &#125;    </span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">for in 效率低 for、while、forin中while效率最好,以下采用while遍历</span></span><br><span class="line"><span class="comment">	const keys = isArray ? undefined : Object.keys(target);</span></span><br><span class="line"><span class="comment">    forEach(keys || target, (value, key) =&gt; &#123;</span></span><br><span class="line"><span class="comment">        if(keys) &#123;</span></span><br><span class="line"><span class="comment">            key = value;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cloneTarget[key] = clone2(target[key], map);</span></span><br><span class="line"><span class="comment">    &#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三方库 jQuery.extend</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.extend( <span class="literal">true</span>, object1, object2 ); <span class="comment">// 深度拷贝</span></span><br><span class="line">$.extend( object1, object2 );  <span class="comment">// 浅拷贝</span></span><br></pre></td></tr></table></figure>

<p>还有更高级的考虑更全面的深拷贝:(参考)</p>
<p><a href="https://mp.weixin.qq.com/s/gQhfwoaxqHh4hRG1BQqKow" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gQhfwoaxqHh4hRG1BQqKow</a></p>
<h3 id="rem和em和px的区别"><a href="#rem和em和px的区别" class="headerlink" title="rem和em和px的区别"></a>rem和em和px的区别</h3><p>px：绝对单位，页面按精确像bai素展示。</p>
<p>em：相对单位，基du准点为父节点字体的大小，如zhi果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</p>
<p>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。</p>
<h3 id="for循环中break和continue的区别是什么"><a href="#for循环中break和continue的区别是什么" class="headerlink" title="for循环中break和continue的区别是什么?"></a>for循环中break和continue的区别是什么?</h3><p>break,跳出整个循环</p>
<p>continue:跳出当次次循环.</p>
<h3 id="如何用原生js给一个按钮的点击事件绑定两个事件处理函数"><a href="#如何用原生js给一个按钮的点击事件绑定两个事件处理函数" class="headerlink" title="如何用原生js给一个按钮的点击事件绑定两个事件处理函数?"></a>如何用原生js给一个按钮的点击事件绑定两个事件处理函数?</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5CDouyaJ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902100849848.png" alt="image-20200902100849848"></p>
<h3 id="js引擎如何实现异步的"><a href="#js引擎如何实现异步的" class="headerlink" title="js引擎如何实现异步的?"></a>js引擎如何实现异步的?</h3><p>首先明确两点：</p>
<p>1.JS 执行机制是单线程。</p>
<p>2.JS的Event loop是JS的执行机制，深入了解Event loop，就等于深入了解JS引擎的执行。</p>
<p>通过事件循环实现异步:遇到异步交给其他线程处理,处理后然后放入任务队列,当这些任务加入到<code>任务队列</code>后并不会立即执行，而是处于等候状态！等主线程处理完了自己的事情后，才来执行任务队列中任务！</p>
<h4 id="宏任务-amp-微任务"><a href="#宏任务-amp-微任务" class="headerlink" title="宏任务 &amp; 微任务"></a>宏任务 &amp; 微任务</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5CDouyaJ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200914222214891.png" alt="image-20200914222214891"></p>
<p>js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue(任务队列)，然后在执行微任务，将微任务放入eventqueue(任务队列)最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 4 3 1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setTimeout 是异步任务,被放到event table</span></span><br><span class="line"><span class="comment">new Promise 是同步任务,被放到主进程里,直接执行打印 console.log('2')</span></span><br><span class="line"><span class="comment">.then里的函数是 异步任务,被放到event table</span></span><br><span class="line"><span class="comment"> console.log('1')是同步代码,被放到主进程里,直接执行</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="什么是防抖节流"><a href="#什么是防抖节流" class="headerlink" title="什么是防抖节流?"></a>什么是防抖节流?</h3><p><strong>函数防抖</strong> 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
<p><strong>函数节流</strong> 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
<p><img src= "/img/loading.gif" data-src="C:%5CUsers%5CDouyaJ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902103731764.png" alt="image-20200902103731764"></p>
<h3 id="什么是函数柯理化"><a href="#什么是函数柯理化" class="headerlink" title="什么是函数柯理化?"></a>什么是函数柯理化?</h3><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<p>函数柯里化就是接收多个参数的函数变换为接收一个函数,并利用了闭包保存变量的特点，并返回接收余下参数，最终能返回结果的技术 。</p>
<p><strong>柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。</strong></p>
<p>curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。</p>
<p>函数柯里化的好处有几个：</p>
<ol>
<li>参数复用；</li>
<li>提前返回；</li>
<li>延迟计算/运行。</li>
</ol>
<p><img src= "/img/loading.gif" data-src="C:%5CUsers%5CDouyaJ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902105429695.png" alt="image-20200902105429695"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有一个接收三个参数的函数A。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们有一个已经封装好了的柯里化通用函数createCurry。他接收bar作为参数，能够将A转化为柯里化函数，返回结果就是这个被转化之后的函数。</span></span><br><span class="line"><span class="keyword">var</span> _A = createCurry(A);</span><br><span class="line"><span class="comment">//那么_A作为createCurry运行的返回函数，他能够处理A的剩余参数。因此下面的运行结果都是等价的。</span></span><br><span class="line">_A(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">_A(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line">_A(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">_A(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line">A(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//闭包,嵌套函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面的运算方式是等价的。</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">_add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>举一个非常常见的例子:</li>
</ul>
<p>如果我们想要验证一串数字是否是正确的手机号，按照普通的思路来做，大家可能是这样封装，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPhone</span>(<span class="params">phoneNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>.test(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果想要验证是否是邮箱呢？这么封装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkEmail</span>(<span class="params">email</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">targetString, reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(targetString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>, <span class="string">'14900000088'</span>);</span><br><span class="line">check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">'test@163.com'</span>);</span><br></pre></td></tr></table></figure>

<p>这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _check = createCurry(check);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkPhone = _check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>);</span><br><span class="line"><span class="keyword">var</span> checkEmail = _check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br></pre></td></tr></table></figure>

<p>最后在使用的时候就会变得更加直观与简洁了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkPhone(<span class="string">'183888888'</span>);</span><br><span class="line">checkEmail(<span class="string">'xxxxx@test.com'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="什么是js事件循环-event-loop"><a href="#什么是js事件循环-event-loop" class="headerlink" title="什么是js事件循环?(event-loop)"></a>什么是js事件循环?(event-loop)</h3><p><strong>1. js单线程</strong></p>
<p>JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。</p>
<p><strong>2. js事件循环</strong></p>
<p>js代码执行过程中会有很多任务，这些任务总的分成两类：</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：</p>
<p>我们解释一下这张图：</p>
<ul>
<li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li>
</ul>
<p>那主线程执行栈何时为空呢？js引擎存在<code>monitoring process</code>进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去<code>Event Queue</code>那里检查是否有等待被调用的函数。</p>
<p>以上就是js运行的整体流程</p>
<p>需要注意的是除了同步任务和异步任务，任务还可以更加细分为macrotask(宏任务)和microtask(微任务)，js引擎会优先执行微任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</span><br><span class="line">宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I&#x2F;O 操作、UI 渲染等。</span><br></pre></td></tr></table></figure>

<p>面试中该如何回答呢？下面是我个人推荐的回答：</p>
<ol>
<li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li>
<li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li>
<li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li>
<li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li>
<li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li>
</ol>
<p>最后可以用下面一道题检测一下收获：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>); </span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">process.nextTick(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//25431</span></span><br></pre></td></tr></table></figure>

<p>第一轮：主线程开始执行，遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？process.nextTick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。</p>
<p>第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431</p>
<h3 id="http和https有什么区别"><a href="#http和https有什么区别" class="headerlink" title="http和https有什么区别?"></a>http和https有什么区别?</h3><p>http协议传输的数据都是未加密的，也就是明文的，因此使用http协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，于是网景公司设计了ssl(Secure Sockets Layer)协议用于对http协议传输的数据进行加密，从而就诞生了https。<br>    简单来说，https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p> https和http的主要区别：<br> 一、https协议需要到ca机构申请ssl证书(如沃通CA)，另外沃通CA还提供3年期的免费ssl证书，高级别的ssl证书需要一定费用。<br> 二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br> 三、http和https使用的是完全不同的连接方式，用的端口也不一样，http是80端口，https是443端口。<br> 四、http的连接很简单，是无状态的;https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<br> 五、如果要实现HTTPS那么可以淘宝Gworg获取SSL证书。</p>
<h3 id="你认为前端页面实时刷新数据的方法有哪些"><a href="#你认为前端页面实时刷新数据的方法有哪些" class="headerlink" title="你认为前端页面实时刷新数据的方法有哪些?"></a>你认为前端页面实时刷新数据的方法有哪些?</h3><ul>
<li><p>轮询</p>
<ul>
<li><p>前端轮询，每请求一次，建立一次连接，后端返回前端数据一次</p>
<p>具体实现：设置定时器，每隔5s请求后端数据，后端返回数据后渲染前端</p>
</li>
</ul>
</li>
<li><p>websocket</p>
<ul>
<li><p>前端请求只建立一次连接，后端能持续主动向前端推送数据</p>
<p>具体实现：前端通过socket方式向后端建立连接，后端定时查询数据库数据，主动向前端推送，这种优点很明显，可以减少网络请求次数</p>
</li>
</ul>
</li>
</ul>
<p>我知道有三种方式： 1，ajax短连接：客户端每隔一秒钟发一次请求，服务器收到请求后会立刻返回结果，不管有没有新数据。 2，ajax长连接：客户端发送一次请求，服务器端收到请求后查询有没有新数据，如果没有新数据就阻塞这个请求，直到有新数据或者超时为止。客户端每次收到请求返回结果后立刻再发一次请求。comet貌似就是这个原理。 3，WebSocket：这就不是一个HTTP协议了，而是一个tcp协议，而且Socket这个玩意顾名思义就是一个流了，可以双向操作。缺点是有些浏览器不支持。<br>对比延迟： 假设网络延迟是m毫秒，那么ajax短连接的延迟在m到1000毫秒之间，另外两种基本只有m毫秒的延迟。 对比资源占用： 应该是1&gt;2&gt;3。但是1和2的比较要看情况，如果两次请求间隔时间很长的话应该是2&gt;1&gt;3。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">吴超</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/22/%E5%89%8D%E7%AB%AFjs%E6%9C%BA%E5%88%B6-%E5%9F%BA%E7%A1%80/">http://yoursite.com/2020/09/22/%E5%89%8D%E7%AB%AFjs%E6%9C%BA%E5%88%B6-%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/22/css-html%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">css-html重点总结</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/22/vue%E5%9F%BA%E7%A1%80/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">vue基础</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 吴超</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font_plus" title="Increase Font Size"><i class="fas fa-plus"></i></button><button id="font_minus" title="Decrease Font Size"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>