<!DOCTYPE html><html lang="中文" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>vue基础 | 吴超的技术博客</title><meta name="description" content="vue组件中watch和computed的区别 watch(侦听器):  该属性可以用来对data或者computed中的数据进行侦听,当侦听的数据发生改变时,watch中所对应的方法就会执行. 是一对多的关系 watch可以做性能消耗较大的事情比如可以发送请求   当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。  computed (计算属性):  当我们需要对data中的数"><meta name="author" content="吴超"><meta name="copyright" content="吴超"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/09/22/vue%E5%9F%BA%E7%A1%80/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="vue基础"><meta property="og:url" content="http://yoursite.com/2020/09/22/vue%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="吴超的技术博客"><meta property="og:description" content="vue组件中watch和computed的区别 watch(侦听器):  该属性可以用来对data或者computed中的数据进行侦听,当侦听的数据发生改变时,watch中所对应的方法就会执行. 是一对多的关系 watch可以做性能消耗较大的事情比如可以发送请求   当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。  computed (计算属性):  当我们需要对data中的数"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-09-22T02:13:36.851Z"><meta property="article:modified_time" content="2020-09-22T02:13:37.872Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="前端js机制-基础" href="http://yoursite.com/2020/09/22/%E5%89%8D%E7%AB%AFjs%E6%9C%BA%E5%88%B6-%E5%9F%BA%E7%A1%80/"><link rel="next" title="作用域,作用域链,闭包,原型" href="http://yoursite.com/2020/09/22/%E4%BD%9C%E7%94%A8%E5%9F%9F,%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE,%E9%97%AD%E5%8C%85,%E5%8E%9F%E5%9E%8B/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page"><span> 列表</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue组件中watch和computed的区别"><span class="toc-number">1.</span> <span class="toc-text">vue组件中watch和computed的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue常用的生命周期钩子函数有哪些-分别有什么作用"><span class="toc-number">2.</span> <span class="toc-text">vue常用的生命周期钩子函数有哪些?分别有什么作用?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Vue生命周期是什么"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">Vue生命周期是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vue生命周期的作用"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">Vue生命周期的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第一次页面加载的时候会触发哪些钩子函数"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">第一次页面加载的时候会触发哪些钩子函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DOM-渲染在-哪个周期中就已经完成？"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">DOM 渲染在 哪个周期中就已经完成？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue如何实现组件通信-组件传值-父子-兄弟-复杂组件关系"><span class="toc-number">3.</span> <span class="toc-text">vue如何实现组件通信(组件传值)?父子 兄弟 复杂组件关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法六、-parent-children与-ref"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">方法六、$parent &#x2F; $children与 ref</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#总结"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue如何提取组件的公共逻辑"><span class="toc-number">4.</span> <span class="toc-text">vue如何提取组件的公共逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mixins的特点"><span class="toc-number">4.1.</span> <span class="toc-text">mixins的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue项目如何做路由拦截"><span class="toc-number">5.</span> <span class="toc-text">vue项目如何做路由拦截?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue响应式原理-Object-defineProperty"><span class="toc-number">6.</span> <span class="toc-text">vue响应式原理 Object.defineProperty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if和v-show的区别"><span class="toc-number">6.1.</span> <span class="toc-text">v-if和v-show的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive组件有什么用"><span class="toc-number">6.2.</span> <span class="toc-text">keep-alive组件有什么用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-nextTick有什么作用"><span class="toc-number">7.</span> <span class="toc-text">this.$nextTick有什么作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue如何做路由懒加载"><span class="toc-number">7.1.</span> <span class="toc-text">vue如何做路由懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法一-resolve"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">方法一 resolve</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法二-官网方法"><span class="toc-number">7.1.0.2.</span> <span class="toc-text">方法二 官网方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-webpack提供的require-ensure"><span class="toc-number">7.1.0.3.</span> <span class="toc-text">3.webpack提供的require.ensure()</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">吴超的技术博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page"><span> 列表</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">vue基础</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-09-22 10:13:36"><i class="far fa-calendar-alt fa-fw"></i> Created 2020-09-22</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-09-22 10:13:37"><i class="fas fa-history fa-fw"></i> Updated 2020-09-22</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="vue组件中watch和computed的区别"><a href="#vue组件中watch和computed的区别" class="headerlink" title="vue组件中watch和computed的区别"></a>vue组件中watch和computed的区别</h2><ul>
<li><p>watch(侦听器):</p>
<ul>
<li>该属性可以用来对data或者computed中的数据进行侦听,当侦听的数据发生改变时,watch中所对应的方法就会执行.</li>
<li>是一对多的关系 <code>watch</code>可以做性能消耗较大的事情比如可以发送请求</li>
</ul>
</li>
<li><p>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>
</li>
<li><p>computed (计算属性):</p>
<ul>
<li>当我们需要对data中的数据做一些额外的操作来得到一个新的数据,同时又不希望改变原数据时,就可以通过计算属性来实现.</li>
<li>是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一 次获取 computed 的值时才会重新计算 computed 的值； 是多对一的关系</li>
<li><strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。</li>
<li>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：<ul>
<li>只有当computed监测的值变化的时候，也就是我下面例子中的fullName变化的时候，set才回被调用:</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      firstName: <span class="string">'Foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ClickCeshi () &#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="string">'fullName的新值'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: &#123;</span><br><span class="line">      <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'调用了getter属性'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'***'</span> + <span class="keyword">this</span>.firstName + <span class="string">'***'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'调用了settter属性'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(newValue)</span><br><span class="line">        <span class="keyword">this</span>.firstName = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="vue常用的生命周期钩子函数有哪些-分别有什么作用"><a href="#vue常用的生命周期钩子函数有哪些-分别有什么作用" class="headerlink" title="vue常用的生命周期钩子函数有哪些?分别有什么作用?"></a>vue常用的生命周期钩子函数有哪些?分别有什么作用?</h2><h5 id="Vue生命周期是什么"><a href="#Vue生命周期是什么" class="headerlink" title="Vue生命周期是什么"></a>Vue生命周期是什么</h5><p>vue生命周期即为一个组件从出生到死亡的一个完整周期，主要包括以下4个阶段：创建，挂载，更新，销毁（从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。）</p>
<h5 id="Vue生命周期的作用"><a href="#Vue生命周期的作用" class="headerlink" title="Vue生命周期的作用"></a>Vue生命周期的作用</h5><p>它的生命周期中有多个事件钩子函数，让我们在控制整个Vue实例的过程时更容易形成好的逻辑</p>
<h5 id="第一次页面加载的时候会触发哪些钩子函数"><a href="#第一次页面加载的时候会触发哪些钩子函数" class="headerlink" title="第一次页面加载的时候会触发哪些钩子函数"></a>第一次页面加载的时候会触发哪些钩子函数</h5><p>第一次页面加载会触发下面这几个beforeCreate, created, beforeMount, mounted钩子函数。</p>
<h5 id="DOM-渲染在-哪个周期中就已经完成？"><a href="#DOM-渲染在-哪个周期中就已经完成？" class="headerlink" title="DOM 渲染在 哪个周期中就已经完成？"></a>DOM 渲染在 哪个周期中就已经完成？</h5><p>DOM 渲染在 mounted 中就已经完成了。</p>
<ul>
<li>创建前：beforeCreate（使用频率低）</li>
</ul>
<p>beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。这时候this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到；</p>
<p><strong>可以做什么——可以添加loading动画</strong></p>
<ul>
<li>创建后：<strong>created</strong>（使用频率高）</li>
</ul>
<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)， 属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见。当前生命周期函数执行的时候会将data中所以的属性和methods身上所以的方法添加到vue的实例身上，同时会将data中所有的属性添加一个getter/setter方法（这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作）</p>
<p><strong>可以做什么——</strong></p>
<p>*<em>1. 结束loading动画 *</em></p>
<p>*<em>2. 发送请求，前后端上数据交互(ajax请求的时候)异步请求也适宜在这里调用  *</em></p>
<p>*<em>3.能修改数据，且修改数据不会触发updated beforeUpdate钩子函数 *</em></p>
<p><strong>4.判断是否存在el，是否存在template，如果二者都有，以template为主优先， 如果 没有template,会选择el模板。如果二者都没有，有$mount 也可以调用模板</strong> </p>
<ul>
<li>挂载前：<strong>beforeMount</strong></li>
</ul>
<p>官方：在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p> render函数初次被调用—-&gt;数据和模板没有进行相结合，同时还没有渲染到html页面上，真实的dom节点挂载到页面之前，完成了 <code>$el</code> 和 <code>$data</code> 的初始化可以在此做渲染前data中数据最后的修改</p>
<p>注意：在beforeMount和mounted之间隐藏了一个render函数，千万不能写，会覆盖系统函数</p>
<ul>
<li>挂载后：<strong>mounted</strong></li>
</ul>
<p><strong>官方说明：</strong><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果<code>root</code>实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>
<p>数据和模板进行相结合，渲染成真实的DOM结构，在当前生命周期函数里面我们可以访问到真实的DOM结构,在vue中我们可以通过$refs来访问到真实的DOM结构（ref类似与id一样 值必须是唯一的  访问的时候我们可以通过this.$refs.属性）</p>
<p><strong>可以做什么——</strong></p>
<p>*<em>1.发起后端请求，拿回数据 *</em></p>
<p><strong>2.配合路由钩子做一些事情</strong></p>
<p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener">vm.$nextTick</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<ul>
<li>更新前：<strong>beforeUpdate</strong></li>
</ul>
<p>只要data中的属性发生了改变，那么这个生命周期就会执行，render函数再次会执行</p>
<p>在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。 在这个生命周期函数中我们可以对数据进行最后的修改，同时也可以访问到最新的DOM结构和数据</p>
<ul>
<li><p>更新后：<strong>updated</strong></p>
<p>在当前生命周期函数中我们可以访问到最新的DOM结构(数据更新后最新的DOM结构)和数据</p>
<p>在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p>
</li>
</ul>
<p>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener">vm.$nextTick</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">updated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been re-rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>activated: 被 keep-alive 缓存的组件激活时调用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>deactivated: 被 keep-alive 缓存的组件停用时调用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>销毁前：<strong>beforeDestroy</strong></p>
</li>
</ul>
<p>在实例销毁之前调用。实例仍然完全可用，能够让我们访问到DOM结构以及相关的数据(data)。</p>
<p><strong>可以做什么——在这个生命周期函数中我们可以将绑定的事件进行移除</strong></p>
<ul>
<li>销毁后：<strong>destroyed</strong></li>
</ul>
<p>在这个生命周期函数中会将数据和模板之间的关系断开，在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。我们还是可以访问到data中的属性，但是访问不到真实的DOM结构了</p>
<p>销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。因为这个Vue实例已经不存在了。</p>
<p>errorCaptured:  2.5.0+ 新增</p>
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>
<h2 id="vue如何实现组件通信-组件传值-父子-兄弟-复杂组件关系"><a href="#vue如何实现组件通信-组件传值-父子-兄弟-复杂组件关系" class="headerlink" title="vue如何实现组件通信(组件传值)?父子 兄弟 复杂组件关系"></a>vue如何实现组件通信(组件传值)?父子 兄弟 复杂组件关系</h2><ul>
<li><strong>父组件通过props向下传递数据给子组件</strong>, 父组件在子组件的标签上自定义属性.子组件props接收</li>
<li><strong>子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</strong>自定义事件</li>
<li>兄弟组件:可以通过状态提升,vuex状态机传值,<strong>中央事件总线</strong></li>
<li>跨级通信:<strong>中央事件总线</strong>Bus；Vuex；provide / inject API、<code>$attrs/$listeners</code></li>
</ul>
<p><strong>中央事件总线</strong></p>
<p>上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'brother1'</span>,&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        mymessage:<span class="string">'hello brother1'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;this is brother1 compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      passData(val)&#123;</span><br><span class="line">        <span class="comment">//触发全局事件globalEvent</span></span><br><span class="line">        bus.$emit(<span class="string">'globalEvent'</span>,val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.component(<span class="string">'brother2'</span>,&#123;</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;this is brother2 compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        mymessage:<span class="string">'hello brother2'</span>,</span><br><span class="line">        brothermessage:<span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">      <span class="comment">//绑定全局事件globalEvent</span></span><br><span class="line">      bus.$on(<span class="string">'globalEvent'</span>,(val)=&gt;&#123;</span><br><span class="line">        <span class="keyword">this</span>.brothermessage=val;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//中央事件总线</span></span><br><span class="line">  <span class="keyword">var</span> bus=<span class="keyword">new</span> Vue();</span><br><span class="line">  <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;brother1&gt;&lt;/brother1&gt;</span></span><br><span class="line"><span class="string">        &lt;brother2&gt;&lt;/brother2&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>4. provide和inject</strong></p>
<p>　　在 Vue.js 的 <code>2.2.0+</code> 版本中添加加了 provide 和 inject 选项。他们成对出现，用于父级组件向下传递数据。</p>
<p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line"> <span class="number">2</span>     inject:[<span class="string">'for'</span>],<span class="comment">//得到父组件传递过来的数据</span></span><br><span class="line"> <span class="number">3</span>     data()&#123;</span><br><span class="line"> <span class="number">4</span>       <span class="keyword">return</span> &#123;</span><br><span class="line"> <span class="number">5</span>         mymessage:<span class="keyword">this</span>.for</span><br><span class="line"> <span class="number">6</span>       &#125;</span><br><span class="line"> <span class="number">7</span>     &#125;,</span><br><span class="line"> <span class="number">8</span>     template:<span class="string">`</span></span><br><span class="line"><span class="string"> 9       &lt;div&gt;</span></span><br><span class="line"><span class="string">10         &lt;input type="tet" v-model="mymessage"&gt;</span></span><br><span class="line"><span class="string">11       &lt;/div&gt;</span></span><br><span class="line"><span class="string">12   &#125;)</span></span><br><span class="line"><span class="string">13   Vue.component('parent',&#123;</span></span><br><span class="line"><span class="string">14     template:`</span></span><br><span class="line"><span class="number">15</span>       &lt;div&gt;</span><br><span class="line"><span class="number">16</span>         &lt;p&gt;<span class="keyword">this</span> is parent compoent!&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">17         &lt;child&gt;&lt;/</span>child&gt;</span><br><span class="line"><span class="number">18</span>       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">19     `,</span></span><br><span class="line"><span class="regexp">20     provide:&#123;</span></span><br><span class="line"><span class="regexp">21       for:'test'</span></span><br><span class="line"><span class="regexp">22     &#125;,</span></span><br><span class="line"><span class="regexp">23     data()&#123;</span></span><br><span class="line"><span class="regexp">24       return &#123;</span></span><br><span class="line"><span class="regexp">25         message:'hello'</span></span><br><span class="line"><span class="regexp">26       &#125;</span></span><br><span class="line"><span class="regexp">27     &#125;</span></span><br><span class="line"><span class="regexp">28   &#125;)</span></span><br></pre></td></tr></table></figure>

<h5 id="方法六、-parent-children与-ref"><a href="#方法六、-parent-children与-ref" class="headerlink" title="方法六、$parent / $children与 ref"></a>方法六、<code>$parent</code> / <code>$children</code>与 <code>ref</code></h5><ul>
<li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
<li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li>
</ul>
<p>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 <code>ref</code>来访问组件的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component-a 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">'Vue.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      <span class="built_in">window</span>.alert(<span class="string">'Hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component-a ref=<span class="string">"comA"</span>&gt;&lt;<span class="regexp">/component-a&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="keyword">const</span> comA = <span class="keyword">this</span>.$refs.comA;</span><br><span class="line">      <span class="built_in">console</span>.log(comA.title);  <span class="comment">// Vue.js</span></span><br><span class="line">      comA.sayHello();  <span class="comment">// 弹窗</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过，<strong>这两种方法的弊端是，无法在跨级或兄弟间通信</strong>。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>常见使用场景可以分为三类：</p>
<ul>
<li>父子通信：</li>
</ul>
<p>父向子传递数据是通过 props，子向父是通过 events（<code>$emit</code>）；通过父链 / 子链也可以通信（<code>$parent</code> / <code>$children</code>）；ref 也可以访问组件实例；provide / inject API；<code>$attrs/$listeners</code></p>
<ul>
<li>兄弟通信：</li>
</ul>
<p>Bus；Vuex</p>
<ul>
<li>跨级通信：</li>
</ul>
<p>Bus；Vuex；provide / inject API、<code>$attrs/$listeners</code></p>
<h2 id="vue如何提取组件的公共逻辑"><a href="#vue如何提取组件的公共逻辑" class="headerlink" title="vue如何提取组件的公共逻辑"></a>vue如何提取组件的公共逻辑</h2><p>混入,mixins</p>
<p><a href="https://blog.csdn.net/fu983531588/article/details/90680873" target="_blank" rel="noopener">https://blog.csdn.net/fu983531588/article/details/90680873</a></p>
<p>vuex</p>
<h3 id="mixins的特点"><a href="#mixins的特点" class="headerlink" title="mixins的特点"></a>mixins的特点</h3><p><strong>1、方法和参数在各组件中不共享</strong></p>
<p>如混入对象中有一个 cont:1的变量,在组件A中改变cont值为5，这时候在组件B中获取这个值，拿到的还是1，还是混入对象里的初始值，数据不共享</p>
<p><strong>2、值为对象的选项</strong></p>
<p>如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的，比如混入对象里有个方法A，组件里也有方法A，这时候在组件里调用的话，执行的是组件里的A方法</p>
<p><strong>3、值为函数的选项</strong></p>
<p>如created,mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用，同一个钩子函数里，会先执行混入对象的东西，再执行本组件的</p>
<p><strong>4、与vuex的区别</strong></p>
<p>vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。</p>
<p>Mixins：可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。</p>
<p><strong>5、与公共组件的区别</strong></p>
<p>组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。</p>
<h2 id="vue项目如何做路由拦截"><a href="#vue项目如何做路由拦截" class="headerlink" title="vue项目如何做路由拦截?"></a>vue项目如何做路由拦截?</h2><p>导航守卫</p>
<p>提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p>
<h2 id="vue响应式原理-Object-defineProperty"><a href="#vue响应式原理-Object-defineProperty" class="headerlink" title="vue响应式原理 Object.defineProperty"></a>vue响应式原理 Object.defineProperty</h2><p>vue.js是采用数据劫持介个发布-订阅者模式的方法，通过object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p><img src= "/img/loading.gif" data-src="C:%5CUsers%5CDouyaJ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200916222319113.png" alt="image-20200916222319113"></p>
<p><img src= "/img/loading.gif" data-src="C:%5CUsers%5CDouyaJ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200903102339162.png" alt="image-20200903102339162"></p>
<h3 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h3><p>v-show指令是通过修改元素的display的CSS属性让其显示或隐藏</p>
<p>v-if指令是直接销毁和重建DOM节点，达到让元素显示和隐藏的效果</p>
<h3 id="keep-alive组件有什么用"><a href="#keep-alive组件有什么用" class="headerlink" title="keep-alive组件有什么用"></a>keep-alive组件有什么用</h3><p>keep-alive标签包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染.</p>
<p>keep-alive用来缓存组件,避免多次加载相应的组件,减少性能消耗，简单一点来说就是从页面1链接到其他页面后回 退到页面1不用在重新执行页面1的代码，只会从缓存中加载之前已经缓存的页面1，这样可以减少加载时间及性能 消耗，提高用户体验性。</p>
<p>⽐如有⼀个列表和⼀个详情，那么⽤户就会经常执⾏打开详情=&gt;返回列表=&gt; 打开详情…这样的话列表和详情都是⼀个频率很⾼的⻚⾯，那么就可以对列表 组件使⽤ `进⾏缓存，这样⽤户每次返回列表的 时候，都能从缓存中快速渲染，⽽不是重新渲染.</p>
<p><code>keep-alive</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 基本 --&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 多个条件判断的子组件 --&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;comp-a v-<span class="keyword">if</span>=<span class="string">"a &gt; 1"</span>&gt;&lt;<span class="regexp">/comp-a&gt;</span></span><br><span class="line"><span class="regexp">  &lt;comp-b v-else&gt;&lt;/</span>comp-b&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;transition&gt;</span></span><br><span class="line"><span class="regexp">  &lt;keep-alive&gt;</span></span><br><span class="line"><span class="regexp">    &lt;component :is="view"&gt;&lt;/</span>component&gt;</span><br><span class="line">  &lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>transition&gt;</span><br></pre></td></tr></table></figure>

<p>注意，<code>是用在其一个直属的子组件被开关的情形。如果你在其中有 `v-for` 则不会工作。如果有上述的多个条件性的子元素，</code> 要求同时只有一个子元素被渲染。</p>
<p><strong>Props</strong>：</p>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 逗号分隔字符串 --&gt;</span><br><span class="line">&lt;keep-alive include=<span class="string">"a,b"</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正则表达式 (使用 <span class="string">`v-bind`</span>) --&gt;</span><br><span class="line">&lt;keep-alive :include=<span class="string">"/a|b/"</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数组 (使用 <span class="string">`v-bind`</span>) --&gt;</span><br><span class="line">&lt;keep-alive :include=<span class="string">"['a', 'b']"</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</span></span><br><span class="line">&lt;keep-alive :max=<span class="string">"10"</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"view"</span>&gt;&lt;<span class="regexp">/component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br></pre></td></tr></table></figure>

<h2 id="this-nextTick有什么作用"><a href="#this-nextTick有什么作用" class="headerlink" title="this.$nextTick有什么作用"></a>this.$nextTick有什么作用</h2><p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 <code>Vue.nextTick</code> 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。</p>
<p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。</p>
<p>例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example"</span>&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#example',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    message: '123'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">vm.message = 'new message' /</span><span class="regexp">/ 更改数据</span></span><br><span class="line"><span class="regexp">vm.$el.textContent === 'new message' /</span><span class="regexp">/ false</span></span><br><span class="line"><span class="regexp">Vue.nextTick(function () &#123;</span></span><br><span class="line"><span class="regexp">  vm.$el.textContent === 'new message' /</span><span class="regexp">/ true</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局 <code>Vue</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'example'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'未更新'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="string">'已更新'</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '未更新'</span></span><br><span class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '已更新'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因为 <code>$nextTick()</code> 返回一个 <code>Promise</code> 对象，所以你可以使用新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">ES2017 async/await</a> 语法完成相同的事情：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  updateMessage: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.message = <span class="string">'已更新'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '未更新'</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.$nextTick()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '已更新'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vue如何做路由懒加载"><a href="#vue如何做路由懒加载" class="headerlink" title="vue如何做路由懒加载"></a>vue如何做路由懒加载</h3><h5 id="方法一-resolve"><a href="#方法一-resolve" class="headerlink" title="方法一 resolve"></a>方法一 resolve</h5><p>这一种方法较常见。它主要是使用了<code>resolve</code>的异步机制，用<code>require</code>代替了<code>import</code>,实现按需加载，下面是代码示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="comment">// import HelloWorld from '@/components/HelloWorld'</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       path: '/',</span></span><br><span class="line"><span class="comment">//       name: 'HelloWorld',</span></span><br><span class="line"><span class="comment">//       component: HelloWorld</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'/'</span>,</span><br><span class="line">          name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">          component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/components/HelloWorld'</span>], resolve)</span><br><span class="line">        &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="方法二-官网方法"><a href="#方法二-官网方法" class="headerlink" title="方法二 官网方法"></a>方法二 <a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">官网方法</a></h5><p><code>vue-router</code>在官网提供了一种方法，可以理解也是为通过<code>Promise</code>的<code>resolve</code>机制。因为<code>Promise</code>函数返回的<code>Promise</code>为<code>resolve</code>组件本身，而我们又可以使用<code>import</code>来导入组件。整合起来代码示例如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="comment">// import HelloWorld from '@/components/HelloWorld'</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       path: '/',</span></span><br><span class="line"><span class="comment">//       name: 'HelloWorld',</span></span><br><span class="line"><span class="comment">//       component: HelloWorld</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'/'</span>,</span><br><span class="line">          name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">          component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/HelloWorld.vue'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-webpack提供的require-ensure"><a href="#3-webpack提供的require-ensure" class="headerlink" title="3.webpack提供的require.ensure()"></a>3.webpack提供的require.ensure()</h5><p>官网中还提供了通过注释语法来提供chunk name的方法，但是webpack的版本要高于2.4的版本。感兴趣的可以到官网了解一下。<br> 方法三 require.ensure<br> 这种模式可以通过参数中的<code>webpackChunkName</code>将js分开打包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">&#x2F;&#x2F; import HelloWorld from &#39;@&#x2F;components&#x2F;HelloWorld&#39;</span><br><span class="line">Vue.use(Router)</span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">&#x2F;&#x2F;     &#123;</span><br><span class="line">&#x2F;&#x2F;       path: &#39;&#x2F;&#39;,</span><br><span class="line">&#x2F;&#x2F;       name: &#39;HelloWorld&#39;,</span><br><span class="line">&#x2F;&#x2F;       component: HelloWorld</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;&#x2F;&#39;,</span><br><span class="line">          name: &#39;HelloWorld&#39;,</span><br><span class="line">          component: resolve &#x3D;&gt; require.ensure([], () &#x3D;&gt; resolve(require(&#39;@&#x2F;components&#x2F;&#39;+componentName)), &#39;webpackChunkName&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">吴超</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/22/vue%E5%9F%BA%E7%A1%80/">http://yoursite.com/2020/09/22/vue%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/22/%E5%89%8D%E7%AB%AFjs%E6%9C%BA%E5%88%B6-%E5%9F%BA%E7%A1%80/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">前端js机制-基础</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/22/%E4%BD%9C%E7%94%A8%E5%9F%9F,%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE,%E9%97%AD%E5%8C%85,%E5%8E%9F%E5%9E%8B/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">作用域,作用域链,闭包,原型</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 吴超</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font_plus" title="Increase Font Size"><i class="fas fa-plus"></i></button><button id="font_minus" title="Decrease Font Size"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>